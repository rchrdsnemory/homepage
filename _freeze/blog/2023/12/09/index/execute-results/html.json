{
  "hash": "31aec6d7725f67c1a95863782578ec10",
  "result": {
    "markdown": "---\ntitle: 'AI Math Tutoring: Using GPT to generate \"step-by-step guidance\"'\ndate: 2023-12-09\ndescription: \"In this post, I show how an AI Tutor feature like \\\"step-by-step guidance\\\" can be built to help students on multi-step math problems, and how this guidance can be validated.\"\nimage: social-image.png\ntwitter-card:\n  image: \"social-image.png\"\nopen-graph:\n  image: \"social-image.png\"\ncategories:\n  - GPT\n  - prompt-engineering\n  - python\n  - R\nfreeze: true\n---\n\n\nImagine you're developing an AI Math Tutor application: You have a set of math questions that student users can answer, along with the correct answers to those questions. Students will sometimes get stuck answering multi-step problems, and in those situations you want them to be able to ask an AI tutor for help. An AI Tutoring interaction that can be helpful is one where a student asks the tutor for step-by-step guidance.\n\n![Simple AI Math Tutor mock-up (mouse cursor is from kindpng.com)](mockup.png)\n\nIn this blog post, I show how a \"step-by-step guidance\" feature could be developed using GPT and prompt engineering, and how this guidance can be validated. As a demonstration, I use a multi-step math problem that I've found GPT-3.5 often struggles to answer. I show how this step-by-step guidance can be validated by asking GPT to solve the problem using its own instructions and then comparing its \"stepwise\" performance against the performance of a baseline model.\n\n# Imports and setup\n\n\n::: {.cell filename='R'}\n\n```{.r .cell-code}\nlibrary(reticulate)\nlibrary(tidyverse)\n# Add OpenAI key to environment\npy_run_string(\"import os\")\npy_run_string(paste0(\"os.environ['OPENAI_API_KEY'] = '\", Sys.getenv('OPENAI_API_KEY'), \"'\"))\n```\n:::\n\n::: {.cell filename='python'}\n\n```{.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport ujson as json\nimport inspect\nimport textwrap\nfrom multiprocessing.pool import ThreadPool\npool = ThreadPool()\n```\n:::\n\n\n# Import python prompting functions\n\nIn order to use parallelization within an interactive notebook using the `multiprocessing` package, it's necessary to write the python functions to-be-parallelized to disk and import them. I'll import the functions here, and introduce these functions later in the post as I use them.\n\n\n::: {.cell filename='python'}\n\n```{.python .cell-code}\nfrom prompt_functions import get_response, baseline_solver, step_generator, stepwise_solver\n```\n:::\n\n\n# Test case\n\nAs a test case, I'll use a math problem that I've found GPT has some difficulty solving. This problem comes from the [GSM8K](https://github.com/openai/grade-school-math) dataset. Although it's a grade school math problem which should be very easy, it requires multiple reasoning steps. If any one step is wrong, the final answer is likely to be incorrect.\n\n\n::: {.cell filename='python'}\n\n```{.python .cell-code}\nquestion = 'Gail has two fish tanks. The first tank is twice the size of the second tank. There are 48 gallons of water in the first tank. She follows the rule of one gallon of water per inch of fish. If she keeps two-inch fish in the second tank and three-inch fish in the first tank, how many more fish would Gail have in the first tank than the second tank if one of the first tank fish eats another?'\nprint(textwrap.fill(question, width=80))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGail has two fish tanks. The first tank is twice the size of the second tank.\nThere are 48 gallons of water in the first tank. She follows the rule of one\ngallon of water per inch of fish. If she keeps two-inch fish in the second tank\nand three-inch fish in the first tank, how many more fish would Gail have in the\nfirst tank than the second tank if one of the first tank fish eats another?\n```\n:::\n:::\n\n\n# Baseline solver\n\nIn order to generate steps that an AI Tutor could suggest to a student, I'll first get GPT to \"discover\" how to correctly solve the problem on its own. I'll use the `baseline_solver()` function, which implements a simple chain-of-thought prompt.\n\n\n::: {.cell filename='python'}\n\n```{.python .cell-code}\nprint(inspect.getsource(baseline_solver))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndef baseline_solver(question):\n    instructions = \"Solve the math problem delimited by triple backticks.\"\n    user_content = f\"```{question}```\\nLet's work this out in a step by step way to be sure we have the right answer\"\n    msg = [\n        {\"role\": \"system\", \"content\": instructions},\n        {\"role\": \"user\", \"content\": user_content}\n    ]\n    solution = get_response(msg=msg, temp=0.5)\n    answer = identify_final_answer(solution)\n    return {\n      'is_correct': answer == '3',\n      'solution': solution,\n      'question': question,\n      'answer': answer\n    }\n```\n:::\n:::\n\n\nI'll give it 100 attempts to solve the problem.\n\n\n::: {.cell filename='python'}\n\n```{.python .cell-code}\ntry: # Read from disk if I've done this already\n  df_baseline = pd.read_json('baseline_solver_results.ndjson')\nexcept:\n  baseline_results = pool.map(baseline_solver, 100*[question])\n  df_baseline = pd.DataFrame(baseline_results, columns=['is_correct', 'solution', 'question', 'answer'])\n  df_baseline.to_json('baseline_solver_results.ndjson', orient='records')\n```\n:::\n\n\n# Identify solution steps\n\nUsing correct answers from the 100 attempts above, I'll pick a few examples and ask GPT to synthesize and generalize the steps. \n\nFor this task I'll use the `step_generator()` function, which asks GPT to synthesize the steps from three different solutions provided as input. It also asks GPT to remove any calculations from those steps, which is important for an AI Tutor -- after all, we don't want to give away the answer!\n\n\n::: {.cell filename='python'}\n\n```{.python .cell-code}\nprint(inspect.getsource(step_generator))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndef step_generator(solutions):\n    instructions = '''\n      You're given three different solutions to a single math problem, delimited by\n      triple hashtags. Synthesize the solutions into a final set of steps to solve\n      the problem. Remove any calculations from the instructions, leaving only the\n      steps.\n    '''\n    user_content = f'''\n      ###\n      Solution 1: \n      {solutions[0]}\n      ---\n      \n      Solution 2: \n      {solutions[1]}\n      ---\n      \n      Solution 3: \n      {solutions[2]}\n      ###\n      \n      Synthesize the three solutions above. Remove any calculations from the \n      instructions, leaving only the steps.\n    '''\n    msg = [\n        {\"role\": \"system\", \"content\": instructions},\n        {\"role\": \"user\", \"content\": user_content}\n    ]\n    return get_response(msg=msg, temp=0.3)\n```\n:::\n:::\n\nHere's what the final set of steps looks like:\n\n\n::: {.cell filename='python'}\n\n```{.python .cell-code}\ntry: # Read from disk if I've done this already\n  f = open(\"steps.txt\", \"r\")\n  steps = f.read()\n  print(steps)\nexcept:\n  solutions = df_baseline[df_baseline['is_correct'] == True]['solution'].values[0:3]\n  steps = step_generator(solutions)\n  \n  f = open(\"steps.txt\", \"w\")\n  f.write(steps)\n  f.close()\n  \n  print(steps)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTo solve the problem, follow these steps:\n\n1. Find the size of the second tank by dividing the size of the first tank by 2.\n2. Determine the number of fish that can be kept in each tank based on the rule of one gallon of water per inch of fish.\n3. Calculate the number of fish that can be kept in the second tank by dividing the size of the second tank by 2.\n4. Calculate the number of fish that can be kept in the first tank by dividing the size of the first tank by 3.\n5. Subtract 1 from the number of fish in the first tank to account for one fish eating another.\n6. Subtract the number of fish in the second tank from the number of fish in the first tank to find the difference.\n7. Determine the final answer, which is the difference in the number of fish between the two tanks.\n```\n:::\n:::\n\n\n# Stepwise solver\n\nNext, I'll validate the steps generated above using `stepwise_solver()`, a function that asks GPT to solve the problem using the steps provided. I expect that providing GPT with the steps above will improve its performance by a significant margin.\n\n\n::: {.cell filename='python'}\n\n```{.python .cell-code}\nprint(inspect.getsource(stepwise_solver))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndef stepwise_solver(question, steps):\n    instructions = \"Solve the math problem in triple backticks, using the steps provided in triple hashtags.\"\n    user_content = f\"```{question}```\\n\\n###{steps}###\"\n    msg = [\n        {\"role\": \"system\", \"content\": instructions},\n        {\"role\": \"user\", \"content\": user_content}\n    ]\n    solution = get_response(msg=msg, temp=0.5)\n    answer = identify_final_answer(solution)\n    return {\n      'is_correct': answer == '3',\n      'solution': solution,\n      'question': question,\n      'steps': steps,\n      'answer': answer\n    }\n```\n:::\n:::\n\n::: {.cell filename='python'}\n\n```{.python .cell-code}\ntry: # Read from disk if I've done this already\n  df_stepwise = pd.read_json('stepwise_solver_results.ndjson')\nexcept:\n  stepwise_results = pool.starmap(stepwise_solver, zip(100*[question], 100*[steps]))\n  df_stepwise = pd.DataFrame(stepwise_results, columns=['is_correct', 'solution', 'question', 'steps', 'answer'])\n  df_stepwise.to_json('stepwise_solver_results.ndjson', orient='records')\n```\n:::\n\n\nHere we can see that by providing the GPT solver with steps derived from correct solutions, performance was almost doubled (from 39% to 77% correct responses). This provides important validation for an AI Tutor with \"step-by-step guidance\" functionality, because now we know that by following these steps the student would be likely to arrive at the correct answer.\n\n\n::: {.cell filename='python'}\n\n```{.python .cell-code}\nprint(f'''\nBaseline solver: {round(np.mean(df_baseline['is_correct'])*100)}% correct\nStepwise solver: {round(np.mean(df_stepwise['is_correct'])*100)}% correct\n''')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nBaseline solver: 39% correct\nStepwise solver: 77% correct\n```\n:::\n:::\n\n::: {.cell filename='R'}\n\n```{.r .cell-code}\ntibble(`Baseline Solver` = 39, `Stepwise Solver` = 77) %>% \n  pivot_longer(everything()) %>%\n  ggplot(aes(x = name, y = value, fill = name)) + \n    geom_col(width = 0.5) + \n    geom_text(aes(x = name, y = value, label = paste0(round(value), '%')), vjust=-0.5) +\n    labs(\n      x = '',\n      y = '% correct (out of 100)',\n      title = 'Validating the step-by-step guidance, performance of the\\nStepwise Solver was roughly double the Baseline Solver.'\n    ) +\n    ylim(0, 100) +\n    theme(legend.position = \"none\",\n          text = element_text(size=14),\n          axis.text.x = element_text(size=12),\n          axis.text.y = element_text(size=12),  \n          axis.title.x = element_text(size=12),\n          axis.title.y = element_text(size=12))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n# AI Tutor interaction\n\nHaving generated and validated the step-by-step guidance, we can now begin to imagine what the user interaction would look like. It could take the form of a single interaction, where a student asks for help and the AI Tutor provides all of the steps at once.\n\n\n::: {.cell filename='python'}\n\n```{.python .cell-code}\nprint(steps)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTo solve the problem, follow these steps:\n\n1. Find the size of the second tank by dividing the size of the first tank by 2.\n2. Determine the number of fish that can be kept in each tank based on the rule of one gallon of water per inch of fish.\n3. Calculate the number of fish that can be kept in the second tank by dividing the size of the second tank by 2.\n4. Calculate the number of fish that can be kept in the first tank by dividing the size of the first tank by 3.\n5. Subtract 1 from the number of fish in the first tank to account for one fish eating another.\n6. Subtract the number of fish in the second tank from the number of fish in the first tank to find the difference.\n7. Determine the final answer, which is the difference in the number of fish between the two tanks.\n```\n:::\n:::\n\n\nOr the AI Tutor could provide the steps one at a time -- i.e., one step is given each time the student asks for help.\n\n\n::: {.cell filename='python'}\n\n```{.python .cell-code}\n# Print step 1\nprint(steps.split('\\n')[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1. Find the size of the second tank by dividing the size of the first tank by 2.\n```\n:::\n:::\n\n::: {.cell filename='python'}\n\n```{.python .cell-code}\n# Print step 2\nprint(steps.split('\\n')[3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2. Determine the number of fish that can be kept in each tank based on the rule of one gallon of water per inch of fish.\n```\n:::\n:::\n\n\nProviding steps one-at-a-time could be implemented as part of a \"progressive\" hint system. In an educational math game, for example, the student could receive full points for giving a correct answer with zero assistance, and the number of points earned could be reduced every time they ask for a step hint.\n\nIn this implementation I've deliberately removed the results from each step. But we could imagine an interaction where the AI first gives a step, and then optionally provides the result obtained at that step. This could help the student figure out at which step they're making a mistake.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}